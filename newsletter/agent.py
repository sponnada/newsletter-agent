import asyncio
import aiohttp
import json
import logging
from datetime import datetime
from typing import List, Dict

from .models import NewsItem
from .sources.hackernews import HackerNewsSource
from .sources.rss import RSSSource

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')
logger = logging.getLogger(__name__)

class NewsletterAgent:
    """Main agent class for aggregating and generating newsletters"""
    
    def __init__(self, config_path: str = "config.json"):
        self.config = self._load_config(config_path)
        self.session = None
        
    def _load_config(self, config_path: str) -> Dict:
        """Load configuration from JSON file"""
        try:
            with open(config_path, 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            logger.warning(f"Config file {config_path} not found. Using default config.")
            return self._get_default_config()
    
    def _get_default_config(self) -> Dict:
        """Default configuration"""
        return {
            "sources": {
                "hackernews": {"enabled": True},
                "rss_feeds": {
                    "enabled": True, 
                    "urls": [
                        "https://feeds.feedburner.com/oreilly/radar",
                        "https://blog.openai.com/rss/"
                    ]
                }
            },
            "preferences": {
                "max_items": 10,
                "include_keywords": [],
                "exclude_keywords": [],
                "min_score": 0
            },
            "output": {
                "format": "markdown",
                "save_to_file": True,
                "filename_template": "newsletter_{date}.md"
            }
        }
    
    async def __aenter__(self):
        """Async context manager entry"""
        self.session = aiohttp.ClientSession()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit"""
        if self.session:
            await self.session.close()
    
    async def aggregate_content(self) -> List[NewsItem]:
        """Aggregate content from all enabled sources"""
        all_items = []
        
        # Fetch from Hacker News
        if self.config["sources"]["hackernews"]["enabled"]:
            hn_source = HackerNewsSource(self.session, self.config["preferences"]["max_items"])
            hn_items = await hn_source.fetch()
            all_items.extend(hn_items)
        
        # Fetch from RSS feeds
        rss_config = self.config["sources"]["rss_feeds"]
        if rss_config["enabled"] and rss_config.get("urls"):
            rss_source = RSSSource(rss_config["urls"])
            rss_items = await rss_source.fetch()
            all_items.extend(rss_items)
        
        # Filter and rank items
        return self._filter_and_rank_items(all_items)
    
    def _filter_and_rank_items(self, items: List[NewsItem]) -> List[NewsItem]:
        """Filter and rank news items based on preferences"""
        prefs = self.config["preferences"]
        filtered_items = []
        
        for item in items:
            # Score filtering
            if item.score < prefs["min_score"]:
                continue
            
            # Keyword filtering
            if not item.matches_keywords(prefs["include_keywords"], prefs["exclude_keywords"]):
                continue
            
            filtered_items.append(item)
        
        # Sort by score (descending) and then by published date
        filtered_items.sort(key=lambda x: (x.score, x.published_at or datetime.min), reverse=True)
        
        # Return top N items
        return filtered_items[:prefs["max_items"]]
    
    def generate_newsletter(self, items: List[NewsItem]) -> str:
        """Generate markdown newsletter"""
        content = f"""# Your Daily Newsletter - {datetime.now().strftime('%Y-%m-%d')}

## Top Highlights ({len(items)} items)

"""
        
        for i, item in enumerate(items, 1):
            content += f"""### {i}. {item.title}
**Source:** {item.source}
"""
            if item.summary:
                content += f"**Summary:** {item.summary}\n"
            
            content += f"**Link:** [{item.title}]({item.url})\n"
            
            if item.score > 0:
                content += f"**Score:** {item.score}\n"
            
            if item.published_at:
                content += f"**Published:** {item.published_at.strftime('%Y-%m-%d %H:%M')}\n"
            
            content += "\n---\n\n"
        
        content += f"""
*Generated by your AI Newsletter Agent at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*
"""
        
        return content
    
    async def save_newsletter(self, content: str):
        """Save newsletter to file"""
        if not self.config["output"]["save_to_file"]:
            return
        
        filename = self.config["output"]["filename_template"].format(
            date=datetime.now().strftime('%Y-%m-%d')
        )
        
        with open(filename, 'w', encoding='utf-8') as f:
            f.write(content)
        
        logger.info(f"Newsletter saved to {filename}")
    
    async def run(self) -> str:
        """Main method to run the newsletter agent"""
        logger.info("Starting newsletter generation...")
        
        # Aggregate content from all sources
        items = await self.aggregate_content()
        
        if not items:
            logger.warning("No items found. Newsletter not generated.")
            return "No items found."
        
        logger.info(f"Found {len(items)} items for newsletter")
        
        # Generate newsletter
        content = self.generate_newsletter(items)
        
        # Save to file
        await self.save_newsletter(content)
        
        logger.info("Newsletter generation complete!")
        return content